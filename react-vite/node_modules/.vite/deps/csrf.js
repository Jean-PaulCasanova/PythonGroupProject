import {
  __commonJS
} from "./chunk-UXIASGQL.js";

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../../node_modules/rndm/index.js
var require_rndm = __commonJS({
  "../../../../node_modules/rndm/index.js"(exports, module) {
    var assert = require_assert();
    var base62 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    var base36 = "abcdefghijklmnopqrstuvwxyz0123456789";
    var base10 = "0123456789";
    exports = module.exports = create(base62);
    exports.base62 = exports;
    exports.base36 = create(base36);
    exports.base10 = create(base10);
    exports.create = create;
    function create(chars) {
      assert(typeof chars === "string", "the list of characters must be a string!");
      var length = Buffer.byteLength(chars);
      return function rndm(len) {
        len = len || 10;
        assert(typeof len === "number" && len >= 0, "the length of the random string must be a number!");
        var salt = "";
        for (var i = 0; i < len; i++)
          salt += chars[Math.floor(length * Math.random())];
        return salt;
      };
    }
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../../node_modules/random-bytes/index.js
var require_random_bytes = __commonJS({
  "../../../../node_modules/random-bytes/index.js"(exports, module) {
    "use strict";
    var crypto = require_crypto();
    var generateAttempts = crypto.randomBytes === crypto.pseudoRandomBytes ? 1 : 3;
    module.exports = randomBytes;
    module.exports.sync = randomBytesSync;
    function randomBytes(size, callback) {
      if (callback !== void 0 && typeof callback !== "function") {
        throw new TypeError("argument callback must be a function");
      }
      if (!callback && !global.Promise) {
        throw new TypeError("argument callback is required");
      }
      if (callback) {
        return generateRandomBytes(size, generateAttempts, callback);
      }
      return new Promise(function executor(resolve, reject) {
        generateRandomBytes(size, generateAttempts, function onRandomBytes(err, str) {
          if (err)
            return reject(err);
          resolve(str);
        });
      });
    }
    function randomBytesSync(size) {
      var err = null;
      for (var i = 0; i < generateAttempts; i++) {
        try {
          return crypto.randomBytes(size);
        } catch (e) {
          err = e;
        }
      }
      throw err;
    }
    function generateRandomBytes(size, attempts, callback) {
      crypto.randomBytes(size, function onRandomBytes(err, buf) {
        if (!err)
          return callback(null, buf);
        if (!--attempts)
          return callback(err);
        setTimeout(generateRandomBytes.bind(null, size, attempts, callback), 10);
      });
    }
  }
});

// ../../../../node_modules/uid-safe/index.js
var require_uid_safe = __commonJS({
  "../../../../node_modules/uid-safe/index.js"(exports, module) {
    "use strict";
    var randomBytes = require_random_bytes();
    var EQUAL_END_REGEXP = /=+$/;
    var PLUS_GLOBAL_REGEXP = /\+/g;
    var SLASH_GLOBAL_REGEXP = /\//g;
    module.exports = uid;
    module.exports.sync = uidSync;
    function uid(length, callback) {
      if (callback !== void 0 && typeof callback !== "function") {
        throw new TypeError("argument callback must be a function");
      }
      if (!callback && !global.Promise) {
        throw new TypeError("argument callback is required");
      }
      if (callback) {
        return generateUid(length, callback);
      }
      return new Promise(function executor(resolve, reject) {
        generateUid(length, function onUid(err, str) {
          if (err)
            return reject(err);
          resolve(str);
        });
      });
    }
    function uidSync(length) {
      return toString(randomBytes.sync(length));
    }
    function generateUid(length, callback) {
      randomBytes(length, function(err, buf) {
        if (err)
          return callback(err);
        callback(null, toString(buf));
      });
    }
    function toString(buf) {
      return buf.toString("base64").replace(EQUAL_END_REGEXP, "").replace(PLUS_GLOBAL_REGEXP, "-").replace(SLASH_GLOBAL_REGEXP, "_");
    }
  }
});

// ../../../../node_modules/tsscmp/lib/index.js
var require_lib = __commonJS({
  "../../../../node_modules/tsscmp/lib/index.js"(exports, module) {
    "use strict";
    var crypto = require_crypto();
    function bufferEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      if (crypto.timingSafeEqual) {
        return crypto.timingSafeEqual(a, b);
      }
      for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    function timeSafeCompare(a, b) {
      var sa = String(a);
      var sb = String(b);
      var key = crypto.pseudoRandomBytes(32);
      var ah = crypto.createHmac("sha256", key).update(sa).digest();
      var bh = crypto.createHmac("sha256", key).update(sb).digest();
      return bufferEqual(ah, bh) && a === b;
    }
    module.exports = timeSafeCompare;
  }
});

// ../../../../node_modules/csrf/index.js
var require_csrf = __commonJS({
  "../../../../node_modules/csrf/index.js"(exports, module) {
    var rndm = require_rndm();
    var uid = require_uid_safe();
    var compare = require_lib();
    var crypto = require_crypto();
    var EQUAL_GLOBAL_REGEXP = /=/g;
    var PLUS_GLOBAL_REGEXP = /\+/g;
    var SLASH_GLOBAL_REGEXP = /\//g;
    module.exports = Tokens;
    function Tokens(options) {
      if (!(this instanceof Tokens)) {
        return new Tokens(options);
      }
      var opts = options || {};
      var saltLength = opts.saltLength !== void 0 ? opts.saltLength : 8;
      if (typeof saltLength !== "number" || !isFinite(saltLength) || saltLength < 1) {
        throw new TypeError("option saltLength must be finite number > 1");
      }
      var secretLength = opts.secretLength !== void 0 ? opts.secretLength : 18;
      if (typeof secretLength !== "number" || !isFinite(secretLength) || secretLength < 1) {
        throw new TypeError("option secretLength must be finite number > 1");
      }
      this.saltLength = saltLength;
      this.secretLength = secretLength;
    }
    Tokens.prototype.create = function create(secret) {
      if (!secret || typeof secret !== "string") {
        throw new TypeError("argument secret is required");
      }
      return this._tokenize(secret, rndm(this.saltLength));
    };
    Tokens.prototype.secret = function secret(callback) {
      return uid(this.secretLength, callback);
    };
    Tokens.prototype.secretSync = function secretSync() {
      return uid.sync(this.secretLength);
    };
    Tokens.prototype._tokenize = function tokenize(secret, salt) {
      return salt + "-" + hash(salt + "-" + secret);
    };
    Tokens.prototype.verify = function verify(secret, token) {
      if (!secret || typeof secret !== "string") {
        return false;
      }
      if (!token || typeof token !== "string") {
        return false;
      }
      var index = token.indexOf("-");
      if (index === -1) {
        return false;
      }
      var salt = token.substr(0, index);
      var expected = this._tokenize(secret, salt);
      return compare(token, expected);
    };
    function hash(str) {
      return crypto.createHash("sha1").update(str, "ascii").digest("base64").replace(PLUS_GLOBAL_REGEXP, "-").replace(SLASH_GLOBAL_REGEXP, "_").replace(EQUAL_GLOBAL_REGEXP, "");
    }
  }
});
export default require_csrf();
/*! Bundled license information:

random-bytes/index.js:
  (*!
   * random-bytes
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

uid-safe/index.js:
  (*!
   * uid-safe
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

csrf/index.js:
  (*!
   * csrf
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=csrf.js.map
